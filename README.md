# jude-nmf
Non-negative matrix factorization applied to Wasserman's collation of the epistle of Jude.
## Basic Information
The text-critical practice of grouping witnesses into families or texttypes often faces two obstacles: contamination, or mixture in the manuscript tradition, and the circular problem of isolating characteristic readings and manuscripts. Non-negative matrix factorization (NMF) is a simple, unsupervised, and efficient solution to both problems. Within minutes, NMF can cluster hundreds of manuscripts and readings simultaneously, producing an output that details potential contamination according to an easy-to-interpret mixture model. 

We have applied this method to Tommy Wasserman's extensive collation of 560 manuscripts (MSS) of the New Testament epistle of Jude (*The Epistle of Jude: Its Text and Transmission*, ConBNT 43 \[Stockholm: Almqvist & Wiksell International, 2006\]), and we have found that the resulting clusters correspond to human-identified textual families, and their characteristic readings correctly divide witnesses into their groups. Due to its accuracy, versatility, and speed, NMF could fruitfully replace pairwise dissimilarity measures as the pre-genealogical step in the Coherence-Based Genealogical Method and other approaches.

## What Is Non-negative Matrix Factorization?
Suppose we have a collation consisting of *n* MSS and *m* readings (in total across however many variation units there are), and suppose we want to find *k* underlying textual groups that best classify the extant MSS and readings. We can easily encode our collation as an *m* × *n* matrix *X* with 0-1 values. As its name suggests, NMF attempts to find a matrix product *WH* = *X*, where *W* is an *m* × *k* matrix called the *basis matrix*, *H* is a *k* × *n* matrix called the *mixture matrix*, and both *W* and *H* have only non-negative values. In general, the constraints imposed on the factorization will not result in factors *W* and *H* whose product exactly equals *X*, so NMF typically involves finding *W* and *H* whose product is as close as possible to *X*.

In the context of classifying MSS and readings, the coefficients in the basis matrix *W* tell us which readings are the most characteristic of each textual group. Naturally, isolated readings may not have strong basis coefficients for any group, as they are not informative regarding group membership, while other readings may be characteristic of more than one group (reflecting either polygenesis or shared ancestry of the groups involved). Likewise, the coefficients in the mixture matrix *H* tell us the degree to which each MS can be considered a member of a given group. The MSS with the highest coefficients for a given group are those that are most representative of that group. Meanwhile, MSS with smaller coefficients divided over multiple groups may be the result of contamination.

## Data Encoding and Factorization Method
In encoding Wasserman's data, we excluded fragmentary sources, including corrections, alternate readings, and commentaries. We encoded all unambiguous readings, including omissions, as rows in the collation matrix, with MSS represented by columns. To prevent lacunose MSS from influencing cluster divisions, we treated all MSS with fewer than 300 readings as fragmentary and postponed their classification to a later step. The result was a 1346 × 518 collation matrix with 172932 non-zero entries.

In testing different values for the factorization rank *k* (i.e., the desired number of underlying textual groups), we found *k* = 13 to give the best results. We have therefore included only the factorization results for 13 groups. The classifications for the non-fragmentary MSS and the fragmentary MSS are available in separate Excel spreadsheets.

For the factorizations, we used NIMFA, a Python library dedicated to NMF (Marinka Žitnik and Blaž Zupan, "NIMFA: A Python Library for Nonnegative Matrix Factorization," *Journal of Machine Learning Research* 13 \[2012\], 849–853; this library is open source and can be downloaded at https://github.com/marinkaz/nimfa.). We factored our data matrix using the LSNMF method (alternating nonnegative least squares using projected gradient), with the initial entries of *W* and *H* set using NNDSVD (nonnegative double singular value decomposition) seeding.
